<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Snake</title>
  </head>
  <body>
    <canvas id="game-field" width="700" height="500"></canvas>
  </body>
  <script>
    const screen = document.getElementById("game-field");

    const yTiles = 10;
    const xTiles = 14;

    let snake = [];
    let fruit = {};

    let gameSpeed = 1;

    // TODO Score counter

    function resetGame() {
      snake = [
        { x: 2, y: 0 },
        { x: 1, y: 0 },
        { x: 0, y: 0 },
      ];

      turn('right')

      makeFruit();
    }

    function makeFruit() {
      let whereSnakeIsnt = [];
      for (let x = 0; x < xTiles; x++) {
        for (let y = 0; y < yTiles; y++) {
          if (!snake.find((segment) => segment.x === x && segment.y === y)) {
            whereSnakeIsnt.push({ x, y });
          }
        }
      }

      const rand = Math.floor(
        Math.random() * Math.floor(whereSnakeIsnt.length)
      );

      fruit = { x: whereSnakeIsnt[rand].x, y: whereSnakeIsnt[rand].y };
    }

    function hasHitSelf() {
      let body = snake.slice(1);
      let head = { ...snake[0] };

      return body.some(
        (segment) => segment.x === head.x && segment.y === head.y
      );
    }

    function hasHitEdge() {
      const head = { ...snake[0] };

      const hitTop = head.y < 0;
      const hitRight = head.x > xTiles - 1;
      const hitBottom = head.y > yTiles - 1;
      const hitLeft = head.x < 0;

      return hitTop || hitRight || hitBottom || hitLeft;
    }

    function eatenFruit() {
      const head = { ...snake[0] };

      return head.x === fruit.x && head.y === fruit.y;
    }

    function growSnake() {
      snake.push(snake[snake.length - 1]);
    }

    function turn(newDirection) {
      // TODO check to stop reversing into self. e.g. going left then switching to right
      const turn = {
        up: { x: 0, y: -1 },
        right: { x: 1, y: -0 },
        down: { x: 0, y: 1 },
        left: { x: -1, y: 0 },
      };

      direction = turn[newDirection]
    }

    function moveSnake(direction) {
      const head = { ...snake[0] };

      snake.pop();
      snake.unshift({
        x: (head.x += direction.x),
        y: (head.y += direction.y),
      });
    }

    function handleInput({ code }) {
      switch (code) {
        case "KeyW":
        case "ArrowUp":
          turn("up");
          break;
        case "KeyD":
        case "ArrowRight":
          turn("right");
          break;
        case "KeyS":
        case "ArrowDown":
          turn("down");
          break;
        case "KeyA":
        case "ArrowLeft":
          turn("left");
          break;
        case "Space":
          growSnake();
          break;
        case "KeyE":
          makeFruit();
          break;
        case "KeyF":
          resetGame();
          break;
      }
    }

    function cycleGame(direction) {
      moveSnake(direction);

      if (eatenFruit()) {
        growSnake();
        if (snake.length >= yTiles * xTiles) {
          resetGame();
          alert("You Win!");
        }
        makeFruit();
      }

      if (hasHitSelf() || hasHitEdge()) {
        resetGame();
        alert("Game Over");
      }
    }

    function drawScreen(snake, fruitPos) {
      // TODO Optimize draw function
      if (screen.getContext) {
        const ctx = screen.getContext("2d", { alpha: false });

        const tileWidth = screen.offsetWidth / xTiles;
        const tileHeight = screen.offsetHeight / yTiles;

        for (let x = 0; x < xTiles; x++) {
          for (let y = 0; y < yTiles; y++) {
            // TODO Replace isSnake with direct translation
            // TODO Replace isFruit with direct translation
            const isSnake = snake.find(
              (segment) => segment.x === x && segment.y === y
            );
            const isFruit = fruit.x === x && fruit.y === y;

            ctx.fillStyle = isSnake ? "white" : isFruit ? "red" : "grey";
            ctx.fillRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
          }
        }
      }
    }

    resetGame();

    window.addEventListener("keydown", (key) => handleInput(key));

    // TODO Implement speed increment
    window.setInterval(() => {
      cycleGame(direction);
      drawScreen(snake);
    }, 250);
  </script>
  <style>
    body {
      height: 100vh;
      width: 100vw;
      margin: 0;
      background: #000;
    }
    #game-field {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      margin: auto;
      background: #222;
    }
  </style>
</html>
