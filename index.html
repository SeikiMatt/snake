<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Snake</title>
  </head>
  <body>
    <canvas id="game-field" width="1000" height="500"></canvas>
  </body>
  <script>
    const screen = document.getElementById("game-field");

    const rows = 25;
    const cols = 50;

    //const gameGrid = Array.from(Array(rows), () => new Array(cols).fill(0));

    let snake = [
      [9, 0],
      [8, 0],
      [7, 0],
      [6, 0],
      [5, 0],
      [4, 0],
      [3, 0],
      [2, 0],
      [1, 0],
      [0, 0],
    ];

    let fruit = [];

    // TODO Score counter

    function generateFruit() {
      let whereSnakeIsnt = [];
      for (let x = 0; x < cols; x++) {
        for (let y = 0; y < rows; y++) {
          if (!snake.find((segment) => segment[0] === x && segment[1] === y)) {
            whereSnakeIsnt.push([x, y]);
          }
        }
      }

      const rand = Math.floor(
        Math.random() * Math.floor(whereSnakeIsnt.length)
      );

      fruit = whereSnakeIsnt[rand];
    }

    function checkSelfCollision() {
      let body = snake.slice(1);
      let head = snake[0].concat();

      return body.some(
        (segment) => segment[0] === head[0] && segment[1] === head[1]
      );
    }

    function checkEdgeCollision() {
      const head = snake[0].concat();

      const pastTop = head[1] < 0;
      const pastRight = head[0] > cols - 1;
      const pastBottom = head[1] > rows - 1;
      const pastLeft = head[0] < 0;

      return pastTop || pastRight || pastBottom || pastLeft;
    }

    function growSnake() {
      snake.push(snake[snake.length - 1]);
    }

    function moveSnake(direction) {
      let headLastPos = snake[0].concat();

      snake.pop();
      snake.unshift([
        (headLastPos[0] += direction[0]),
        (headLastPos[1] += direction[1]),
      ]);
    }

    function cycleGame(direction) {
      // TODO Fruit pickup detection

      moveSnake(direction);
      
      if (checkSelfCollision() || checkEdgeCollision()) alert("Game Over");

      return snake;
    }

    function handleInput({ code }) {
      switch (code) {
        case "KeyW":
        case "ArrowUp":
          cycleGame([0, -1]);
          break;
        case "KeyD":
        case "ArrowRight":
          cycleGame([1, -0]);
          break;
        case "KeyS":
        case "ArrowDown":
          cycleGame([0, 1]);
          break;
        case "KeyA":
        case "ArrowLeft":
          cycleGame([-1, 0]);
          break;
        case "Space":
          growSnake();
          break;
        case "KeyE":
          generateFruit();
          break;
      }
    }

    function drawScreen(snake, fruitPos) {
      // TODO Optimize draw function
      if (screen.getContext) {
        const ctx = screen.getContext("2d", { alpha: false });

        const tileWidth = screen.offsetWidth / cols;
        const tileHeight = screen.offsetHeight / rows;

        for (let x = 0; x < cols; x++) {
          for (let y = 0; y < rows; y++) {
            const isSnake = snake.find(
              (segment) => segment[0] === x && segment[1] === y
            );
            const isFruit = fruit[0] === x && fruit[1] === y;

            ctx.fillStyle = isSnake ? "white" 
            : isFruit ? "red" 
            : "grey";
            ctx.fillRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
          }
        }
      }
    }

    generateFruit()

    window.addEventListener("keydown", (key) => handleInput(key));

    window.setInterval(() => {
      drawScreen(snake);
    }, 16.7);
  </script>
  <style>
    body {
      height: 100vh;
      width: 100vw;
      margin: 0;
      background: #000;
    }
    #game-field {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      margin: auto;
      background: #222;
    }
  </style>
</html>
